// ============================================
// üí∞ SYST√àME DE MESSAGES AUTOMATIQUES POUR LES CAUTIONS
// ============================================

/**
 * R√©cup√©rer les infos de la propri√©t√© pour le message
 */
async function getPropertyInfo(pool, propertyId) {
  try {
    const result = await pool.query(
      'SELECT name, address FROM properties WHERE id = $1',
      [propertyId]
    );
    return result.rows[0] || null;
  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration propri√©t√©:', error);
    return null;
  }
}

/**
 * R√©cup√©rer la conversation li√©e √† une r√©servation
 */
async function getConversationFromReservation(pool, reservationUid) {
  try {
    // D'abord, trouver la r√©servation par UID
    const reservationResult = await pool.query(
      'SELECT id FROM reservations WHERE uid = $1',
      [reservationUid]
    );

    if (reservationResult.rows.length === 0) {
      return null;
    }

    const reservationId = reservationResult.rows[0].id;

    // Ensuite, trouver la conversation
    const conversationResult = await pool.query(
      'SELECT id FROM conversations WHERE reservation_id = $1',
      [reservationId]
    );

    return conversationResult.rows[0]?.id || null;
  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration conversation:', error);
    return null;
  }
}

/**
 * Envoyer un message dans le chat
 */
async function sendDepositMessage(pool, io, conversationId, message) {
  try {
    const messageResult = await pool.query(
      `INSERT INTO messages (conversation_id, sender_type, message, is_read, created_at)
       VALUES ($1, 'system', $2, FALSE, NOW())
       RETURNING id, conversation_id, sender_type, message, is_read, created_at`,
      [conversationId, message]
    );

    const savedMessage = messageResult.rows[0];

    // √âmettre via Socket.io
    if (io) {
      io.to(`conversation_${conversationId}`).emit('new_message', savedMessage);
    }

    console.log(`‚úÖ Message caution envoy√© pour conversation ${conversationId}`);
    return true;
  } catch (error) {
    console.error(`‚ùå Erreur envoi message caution:`, error);
    return false;
  }
}

/**
 * MESSAGE J-2 : Rappel caution obligatoire
 */
async function sendDepositReminderJ2(pool, io) {
  try {
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    // Date J+2 (dans 2 jours)
    const targetDate = new Date(today);
    targetDate.setDate(targetDate.getDate() + 2);
    const targetDateStr = targetDate.toISOString().split('T')[0];

    console.log(`\nüí∞ ============================================`);
    console.log(`üí∞ RAPPELS CAUTION J-2 (arriv√©es du ${targetDateStr})`);
    console.log(`üí∞ ============================================\n`);

    // R√©cup√©rer toutes les cautions avec arriv√©e J+2, status pending, et reminder non envoy√©
    const depositsResult = await pool.query(
      `SELECT 
        d.id,
        d.property_id,
        d.reservation_uid,
        d.amount_cents,
        d.checkout_url,
        d.status,
        r.start_date as check_in_date,
        r.guest_name
      FROM deposits d
      LEFT JOIN reservations r ON d.reservation_uid = r.uid
      WHERE DATE(r.start_date) = $1
        AND d.status = 'pending'
        AND (d.reminder_sent IS NULL OR d.reminder_sent = FALSE)
      ORDER BY d.id`,
      [targetDateStr]
    );

    const deposits = depositsResult.rows;
    console.log(`üìä ${deposits.length} caution(s) en attente de rappel`);

    if (deposits.length === 0) {
      console.log('‚úÖ Aucun rappel √† envoyer\n');
      return { total: 0, sent: 0, errors: 0 };
    }

    let sent = 0;
    let errors = 0;

    for (const deposit of deposits) {
      try {
        // R√©cup√©rer la conversation
        const conversationId = await getConversationFromReservation(pool, deposit.reservation_uid);
        
        if (!conversationId) {
          console.log(`‚ö†Ô∏è Pas de conversation pour r√©servation ${deposit.reservation_uid}`);
          errors++;
          continue;
        }

        // R√©cup√©rer les infos de la propri√©t√©
        const property = await getPropertyInfo(pool, deposit.property_id);
        const propertyName = property?.name || 'votre logement';

        // Construire le message
        const amountEuros = (deposit.amount_cents / 100).toFixed(2);
        const message = `‚ö†Ô∏è Caution obligatoire

Bonjour,

Une caution de ${amountEuros}‚Ç¨ est requise pour votre s√©jour √† ${propertyName}.

üëâ Cliquez ici pour autoriser la caution :
${deposit.checkout_url}

‚ö†Ô∏è Sans cette autorisation, vous ne pourrez pas recevoir les informations d'arriv√©e.

L'autorisation ne d√©bite pas votre carte imm√©diatement. Le montant sera juste bloqu√© temporairement.

Merci ! üòä`;

        // Envoyer le message
        const success = await sendDepositMessage(pool, io, conversationId, message);

        if (success) {
          // Marquer le reminder comme envoy√©
          await pool.query(
            'UPDATE deposits SET reminder_sent = TRUE, updated_at = NOW() WHERE id = $1',
            [deposit.id]
          );
          
          console.log(`‚úÖ Rappel envoy√© pour ${deposit.guest_name} - ${propertyName}`);
          sent++;
        } else {
          errors++;
        }

        // Petite pause entre chaque envoi
        await new Promise(resolve => setTimeout(resolve, 500));

      } catch (error) {
        console.error(`‚ùå Erreur traitement caution ${deposit.id}:`, error);
        errors++;
      }
    }

    console.log(`\nüìä R√âSUM√â RAPPELS J-2:`);
    console.log(`   ‚úÖ Envoy√©s: ${sent}`);
    console.log(`   ‚ùå Erreurs: ${errors}`);
    console.log(`   üì¶ Total: ${deposits.length}\n`);

    return { total: deposits.length, sent, errors };

  } catch (error) {
    console.error('‚ùå Erreur sendDepositReminderJ2:', error);
    return { total: 0, sent: 0, errors: 0 };
  }
}

/**
 * MESSAGE : Caution autoris√©e
 */
async function sendDepositAuthorizedMessage(pool, io, depositId) {
  try {
    console.log(`üí≥ Envoi message autorisation pour caution ${depositId}`);

    // R√©cup√©rer les infos de la caution
    const depositResult = await pool.query(
      `SELECT 
        d.id,
        d.property_id,
        d.reservation_uid,
        d.amount_cents,
        r.guest_name
      FROM deposits d
      LEFT JOIN reservations r ON d.reservation_uid = r.uid
      WHERE d.id = $1`,
      [depositId]
    );

    if (depositResult.rows.length === 0) {
      console.log(`‚ö†Ô∏è Caution ${depositId} introuvable`);
      return false;
    }

    const deposit = depositResult.rows[0];

    // R√©cup√©rer la conversation
    const conversationId = await getConversationFromReservation(pool, deposit.reservation_uid);
    
    if (!conversationId) {
      console.log(`‚ö†Ô∏è Pas de conversation pour r√©servation ${deposit.reservation_uid}`);
      return false;
    }

    // R√©cup√©rer les infos de la propri√©t√©
    const property = await getPropertyInfo(pool, deposit.property_id);
    const propertyName = property?.name || 'votre logement';

    // Construire le message
    const amountEuros = (deposit.amount_cents / 100).toFixed(2);
    const message = `‚úÖ Caution autoris√©e

Parfait ! Votre caution de ${amountEuros}‚Ç¨ a bien √©t√© autoris√©e.

Vous recevrez les informations d'arriv√©e pour ${propertyName} le jour de votre arriv√©e √† 7h00.

√Ä tr√®s bient√¥t ! üòä`;

    // Envoyer le message
    return await sendDepositMessage(pool, io, conversationId, message);

  } catch (error) {
    console.error(`‚ùå Erreur sendDepositAuthorizedMessage:`, error);
    return false;
  }
}

/**
 * MESSAGE : Caution lib√©r√©e
 */
async function sendDepositReleasedMessage(pool, io, depositId) {
  try {
    console.log(`üéâ Envoi message lib√©ration pour caution ${depositId}`);

    // R√©cup√©rer les infos de la caution
    const depositResult = await pool.query(
      `SELECT 
        d.id,
        d.property_id,
        d.reservation_uid,
        d.amount_cents,
        r.guest_name
      FROM deposits d
      LEFT JOIN reservations r ON d.reservation_uid = r.uid
      WHERE d.id = $1`,
      [depositId]
    );

    if (depositResult.rows.length === 0) {
      console.log(`‚ö†Ô∏è Caution ${depositId} introuvable`);
      return false;
    }

    const deposit = depositResult.rows[0];

    // R√©cup√©rer la conversation
    const conversationId = await getConversationFromReservation(pool, deposit.reservation_uid);
    
    if (!conversationId) {
      console.log(`‚ö†Ô∏è Pas de conversation pour r√©servation ${deposit.reservation_uid}`);
      return false;
    }

    // R√©cup√©rer les infos de la propri√©t√©
    const property = await getPropertyInfo(pool, deposit.property_id);
    const propertyName = property?.name || 'votre logement';

    // Construire le message
    const amountEuros = (deposit.amount_cents / 100).toFixed(2);
    const message = `üéâ Caution lib√©r√©e

Bonne nouvelle ! Votre caution de ${amountEuros}‚Ç¨ pour ${propertyName} a √©t√© lib√©r√©e.

Merci pour votre s√©jour et √† tr√®s bient√¥t ! üòä`;

    // Envoyer le message
    return await sendDepositMessage(pool, io, conversationId, message);

  } catch (error) {
    console.error(`‚ùå Erreur sendDepositReleasedMessage:`, error);
    return false;
  }
}

/**
 * MESSAGE : √âchec autorisation caution
 */
async function sendDepositFailedMessage(pool, io, depositId) {
  try {
    console.log(`‚ùå Envoi message √©chec pour caution ${depositId}`);

    // R√©cup√©rer les infos de la caution
    const depositResult = await pool.query(
      `SELECT 
        d.id,
        d.property_id,
        d.reservation_uid,
        d.amount_cents,
        d.checkout_url,
        r.guest_name
      FROM deposits d
      LEFT JOIN reservations r ON d.reservation_uid = r.uid
      WHERE d.id = $1`,
      [depositId]
    );

    if (depositResult.rows.length === 0) {
      console.log(`‚ö†Ô∏è Caution ${depositId} introuvable`);
      return false;
    }

    const deposit = depositResult.rows[0];

    // R√©cup√©rer la conversation
    const conversationId = await getConversationFromReservation(pool, deposit.reservation_uid);
    
    if (!conversationId) {
      console.log(`‚ö†Ô∏è Pas de conversation pour r√©servation ${deposit.reservation_uid}`);
      return false;
    }

    // R√©cup√©rer les infos de la propri√©t√©
    const property = await getPropertyInfo(pool, deposit.property_id);
    const propertyName = property?.name || 'votre logement';

    // Construire le message
    const amountEuros = (deposit.amount_cents / 100).toFixed(2);
    const message = `‚ùå √âchec de l'autorisation

L'autorisation de la caution de ${amountEuros}‚Ç¨ a √©chou√©.

üëâ Veuillez r√©essayer en cliquant ici :
${deposit.checkout_url}

‚ö†Ô∏è Sans cette autorisation, vous ne pourrez pas acc√©der √† ${propertyName}.

Si le probl√®me persiste, contactez votre banque ou utilisez une autre carte.

Merci ! üòä`;

    // Envoyer le message
    return await sendDepositMessage(pool, io, conversationId, message);

  } catch (error) {
    console.error(`‚ùå Erreur sendDepositFailedMessage:`, error);
    return false;
  }
}

/**
 * V√©rifier si une caution bloque l'envoi des infos d'arriv√©e
 */
async function hasValidDeposit(pool, reservationUid) {
  try {
    const result = await pool.query(
      `SELECT status 
       FROM deposits 
       WHERE reservation_uid = $1 
       ORDER BY created_at DESC 
       LIMIT 1`,
      [reservationUid]
    );

    if (result.rows.length === 0) {
      // Pas de caution = OK, on peut envoyer les infos
      return true;
    }

    const status = result.rows[0].status;

    // Les infos d'arriv√©e peuvent √™tre envoy√©es si :
    // - La caution est autoris√©e (authorized)
    // - La caution est captur√©e (captured)
    // - La caution est lib√©r√©e (released)
    const validStatuses = ['authorized', 'captured', 'released'];

    if (validStatuses.includes(status)) {
      return true;
    }

    console.log(`‚è≠Ô∏è Caution en attente (status: ${status}), infos d'arriv√©e bloqu√©es`);
    return false;

  } catch (error) {
    console.error('‚ùå Erreur hasValidDeposit:', error);
    // En cas d'erreur, on autorise l'envoi (fail-safe)
    return true;
  }
}

module.exports = {
  sendDepositReminderJ2,
  sendDepositAuthorizedMessage,
  sendDepositReleasedMessage,
  sendDepositFailedMessage,
  hasValidDeposit
};
