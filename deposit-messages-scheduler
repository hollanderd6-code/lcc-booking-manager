// ============================================
// üí∞ SYST√àME DE MESSAGES AUTOMATIQUES POUR LES CAUTIONS
// ============================================

/**
 * R√©cup√©rer les infos de la propri√©t√© pour le message
 */
async function getPropertyInfo(pool, propertyId) {
  try {
    const result = await pool.query(
      'SELECT name, address FROM properties WHERE id = $1',
      [propertyId]
    );
    return result.rows[0] || null;
  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration propri√©t√©:', error);
    return null;
  }
}

/**
 * R√©cup√©rer la conversation li√©e √† une r√©servation
 */
async function getConversationFromReservation(pool, reservationUid) {
  try {
    // D'abord, trouver la r√©servation par UID
    const reservationResult = await pool.query(
      'SELECT id, property_id, start_date, source FROM reservations WHERE uid = $1',
      [reservationUid]
    );

    if (reservationResult.rows.length === 0) {
      return null;
    }

    const reservation = reservationResult.rows[0];

    // M√©thode 1 : Chercher par reservation_id
    const conversationResult = await pool.query(
      'SELECT id FROM conversations WHERE reservation_id = $1',
      [reservation.id]
    );

    if (conversationResult.rows[0]?.id) {
      return conversationResult.rows[0].id;
    }

    // M√©thode 2 (fallback) : Chercher par property_id + date d'arriv√©e
    const fallbackResult = await pool.query(
      `SELECT id FROM conversations 
       WHERE property_id = $1 
       AND DATE(reservation_start_date) = DATE($2)
       ORDER BY created_at DESC
       LIMIT 1`,
      [reservation.property_id, reservation.start_date]
    );

    if (fallbackResult.rows[0]?.id) {
      console.log(`üîÑ Conversation trouv√©e par fallback (property + date) pour r√©servation ${reservationUid}`);
      return fallbackResult.rows[0].id;
    }

    return null;
  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration conversation:', error);
    return null;
  }
}

/**
 * Envoyer un message dans le chat
 */
async function sendDepositMessage(pool, io, conversationId, message) {
  try {
    const messageResult = await pool.query(
      `INSERT INTO messages (conversation_id, sender_type, message, is_read, created_at)
       VALUES ($1, 'system', $2, FALSE, NOW())
       RETURNING id, conversation_id, sender_type, message, is_read, created_at`,
      [conversationId, message]
    );

    const savedMessage = messageResult.rows[0];

    // √âmettre via Socket.io
    if (io) {
      io.to(`conversation_${conversationId}`).emit('new_message', savedMessage);
    }

    console.log(`‚úÖ Message caution envoy√© pour conversation ${conversationId}`);
    return true;
  } catch (error) {
    console.error(`‚ùå Erreur envoi message caution:`, error);
    return false;
  }
}

/**
 * MESSAGE J-2 : Rappel caution obligatoire
 */
async function sendDepositReminderJ2(pool, io) {
  try {
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    // Date J+2 (dans 2 jours)
    const targetDate = new Date(today);
    targetDate.setDate(targetDate.getDate() + 2);
    const targetDateStr = targetDate.toISOString().split('T')[0];

    console.log(`\nüí∞ ============================================`);
    console.log(`üí∞ RAPPELS CAUTION J-2 (arriv√©es du ${targetDateStr})`);
    console.log(`üí∞ ============================================\n`);

    // R√©cup√©rer toutes les cautions avec arriv√©e J+2, status pending, et reminder non envoy√©
    const depositsResult = await pool.query(
      `SELECT 
        d.id,
        d.property_id,
        d.reservation_uid,
        d.amount_cents,
        d.checkout_url,
        d.status,
        r.start_date as check_in_date,
        r.guest_name
      FROM deposits d
      LEFT JOIN reservations r ON d.reservation_uid = r.uid
      WHERE DATE(r.start_date) = $1
        AND d.status = 'pending'
        AND (d.reminder_sent IS NULL OR d.reminder_sent = FALSE)
      ORDER BY d.id`,
      [targetDateStr]
    );

    const deposits = depositsResult.rows;
    console.log(`üìä ${deposits.length} caution(s) en attente de rappel`);

    if (deposits.length === 0) {
      console.log('‚úÖ Aucun rappel √† envoyer\n');
      return { total: 0, sent: 0, errors: 0 };
    }

    let sent = 0;
    let errors = 0;

    for (const deposit of deposits) {
      try {
        // R√©cup√©rer la conversation
        const conversationId = await getConversationFromReservation(pool, deposit.reservation_uid);
        
        if (!conversationId) {
          console.log(`‚ö†Ô∏è Pas de conversation pour r√©servation ${deposit.reservation_uid}`);
          errors++;
          continue;
        }

        // R√©cup√©rer les infos de la propri√©t√©
        const property = await getPropertyInfo(pool, deposit.property_id);
        const propertyName = property?.name || 'votre logement';

        // Construire le message
        const amountEuros = (deposit.amount_cents / 100).toFixed(2);
        const message = `‚ö†Ô∏è Caution obligatoire

Bonjour,

Une caution de ${amountEuros}‚Ç¨ est requise pour votre s√©jour √† ${propertyName}.

üëâ Cliquez ici pour autoriser la caution :
${deposit.checkout_url}

‚ö†Ô∏è Sans cette autorisation, vous ne pourrez pas recevoir les informations d'arriv√©e.

L'autorisation ne d√©bite pas votre carte imm√©diatement. Le montant sera juste bloqu√© temporairement.

Merci ! üòä`;

        // Envoyer le message
        const success = await sendDepositMessage(pool, io, conversationId, message);

        if (success) {
          // Marquer le reminder comme envoy√©
          await pool.query(
            'UPDATE deposits SET reminder_sent = TRUE, updated_at = NOW() WHERE id = $1',
            [deposit.id]
          );
          
          console.log(`‚úÖ Rappel envoy√© pour ${deposit.guest_name} - ${propertyName}`);
          sent++;
        } else {
          errors++;
        }

        // Petite pause entre chaque envoi
        await new Promise(resolve => setTimeout(resolve, 500));

      } catch (error) {
        console.error(`‚ùå Erreur traitement caution ${deposit.id}:`, error);
        errors++;
      }
    }

    console.log(`\nüìä R√âSUM√â RAPPELS J-2:`);
    console.log(`   ‚úÖ Envoy√©s: ${sent}`);
    console.log(`   ‚ùå Erreurs: ${errors}`);
    console.log(`   üì¶ Total: ${deposits.length}\n`);

    return { total: deposits.length, sent, errors };

  } catch (error) {
    console.error('‚ùå Erreur sendDepositReminderJ2:', error);
    return { total: 0, sent: 0, errors: 0 };
  }
}

/**
 * MESSAGE : Caution autoris√©e
 */
async function sendDepositAuthorizedMessage(pool, io, depositId) {
  try {
    console.log(`üí≥ Envoi message autorisation pour caution ${depositId}`);

    // R√©cup√©rer les infos de la caution
    const depositResult = await pool.query(
      `SELECT 
        d.id,
        d.property_id,
        d.reservation_uid,
        d.amount_cents,
        r.guest_name
      FROM deposits d
      LEFT JOIN reservations r ON d.reservation_uid = r.uid
      WHERE d.id = $1`,
      [depositId]
    );

    if (depositResult.rows.length === 0) {
      console.log(`‚ö†Ô∏è Caution ${depositId} introuvable`);
      return false;
    }

    const deposit = depositResult.rows[0];

    // R√©cup√©rer la conversation
    const conversationId = await getConversationFromReservation(pool, deposit.reservation_uid);
    
    if (!conversationId) {
      console.log(`‚ö†Ô∏è Pas de conversation pour r√©servation ${deposit.reservation_uid}`);
      return false;
    }

    // R√©cup√©rer les infos de la propri√©t√©
    const property = await getPropertyInfo(pool, deposit.property_id);
    const propertyName = property?.name || 'votre logement';

    // R√©cup√©rer la date d'arriv√©e
    const reservationInfo = await pool.query(
      'SELECT start_date FROM reservations WHERE uid = $1',
      [deposit.reservation_uid]
    );
    const arrivalDate = reservationInfo.rows[0]?.start_date ? new Date(reservationInfo.rows[0].start_date) : null;

    // V√©rifier si c'est le jour J et apr√®s 7h
    const now = new Date();
    const nowParis = new Date(now.toLocaleString('en-US', { timeZone: 'Europe/Paris' }));
    const currentHour = nowParis.getHours();
    
    const todayParis = new Date(nowParis);
    todayParis.setHours(0, 0, 0, 0);
    
    let isArrivalToday = false;
    if (arrivalDate) {
      const arrivalDay = new Date(arrivalDate);
      arrivalDay.setHours(0, 0, 0, 0);
      isArrivalToday = arrivalDay.getTime() === todayParis.getTime();
    }
    
    const isAfter7am = currentHour >= 7;
    const shouldSendNow = isArrivalToday && isAfter7am;

    // Construire le message de confirmation
    const amountEuros = (deposit.amount_cents / 100).toFixed(2);
    
    let confirmMessage;
    if (shouldSendNow) {
      confirmMessage = `‚úÖ Caution autoris√©e

Parfait ! Votre caution de ${amountEuros}‚Ç¨ a bien √©t√© autoris√©e.

Vous allez recevoir les informations d'arriv√©e pour ${propertyName} dans quelques instants. üòä`;
    } else if (isArrivalToday && !isAfter7am) {
      confirmMessage = `‚úÖ Caution autoris√©e

Parfait ! Votre caution de ${amountEuros}‚Ç¨ a bien √©t√© autoris√©e.

Vous recevrez les informations d'arriv√©e pour ${propertyName} √† 7h00 ce matin. üòä`;
    } else {
      confirmMessage = `‚úÖ Caution autoris√©e

Parfait ! Votre caution de ${amountEuros}‚Ç¨ a bien √©t√© autoris√©e.

Vous recevrez les informations d'arriv√©e pour ${propertyName} le jour de votre arriv√©e √† 7h00. üòä`;
    }

    // Envoyer le message de confirmation
    await sendDepositMessage(pool, io, conversationId, confirmMessage);

    // ‚úÖ ENVOYER LE MESSAGE D'ARRIV√âE SI JOUR J APR√àS 7H
    if (shouldSendNow) {
      try {
        const { sendImmediateArrivalMessage } = require('./arrival-messages-scheduler');
        console.log(`üì® [DEPOSIT] Jour J apr√®s 7h ‚Üí envoi imm√©diat du message d'arriv√©e`);
        await sendImmediateArrivalMessage(pool, io, conversationId);
      } catch (arrivalError) {
        console.error('‚ö†Ô∏è Erreur envoi message d\'arriv√©e apr√®s caution:', arrivalError);
      }
    } else {
      console.log(`‚è∞ [DEPOSIT] Pas encore le moment ‚Üí le cron enverra le jour J √† 7h`);
    }

    return true;

  } catch (error) {
    console.error(`‚ùå Erreur sendDepositAuthorizedMessage:`, error);
    return false;
  }
}

/**
 * MESSAGE : Caution lib√©r√©e
 */
async function sendDepositReleasedMessage(pool, io, depositId) {
  try {
    console.log(`üéâ Envoi message lib√©ration pour caution ${depositId}`);

    // R√©cup√©rer les infos de la caution
    const depositResult = await pool.query(
      `SELECT 
        d.id,
        d.property_id,
        d.reservation_uid,
        d.amount_cents,
        r.guest_name
      FROM deposits d
      LEFT JOIN reservations r ON d.reservation_uid = r.uid
      WHERE d.id = $1`,
      [depositId]
    );

    if (depositResult.rows.length === 0) {
      console.log(`‚ö†Ô∏è Caution ${depositId} introuvable`);
      return false;
    }

    const deposit = depositResult.rows[0];

    // R√©cup√©rer la conversation
    const conversationId = await getConversationFromReservation(pool, deposit.reservation_uid);
    
    if (!conversationId) {
      console.log(`‚ö†Ô∏è Pas de conversation pour r√©servation ${deposit.reservation_uid}`);
      return false;
    }

    // R√©cup√©rer les infos de la propri√©t√©
    const property = await getPropertyInfo(pool, deposit.property_id);
    const propertyName = property?.name || 'votre logement';

    // Construire le message
    const amountEuros = (deposit.amount_cents / 100).toFixed(2);
    const message = `üéâ Caution lib√©r√©e

Bonne nouvelle ! Votre caution de ${amountEuros}‚Ç¨ pour ${propertyName} a √©t√© lib√©r√©e.

Merci pour votre s√©jour et √† tr√®s bient√¥t ! üòä`;

    // Envoyer le message
    return await sendDepositMessage(pool, io, conversationId, message);

  } catch (error) {
    console.error(`‚ùå Erreur sendDepositReleasedMessage:`, error);
    return false;
  }
}

/**
 * MESSAGE : √âchec autorisation caution
 */
async function sendDepositFailedMessage(pool, io, depositId) {
  try {
    console.log(`‚ùå Envoi message √©chec pour caution ${depositId}`);

    // R√©cup√©rer les infos de la caution
    const depositResult = await pool.query(
      `SELECT 
        d.id,
        d.property_id,
        d.reservation_uid,
        d.amount_cents,
        d.checkout_url,
        r.guest_name
      FROM deposits d
      LEFT JOIN reservations r ON d.reservation_uid = r.uid
      WHERE d.id = $1`,
      [depositId]
    );

    if (depositResult.rows.length === 0) {
      console.log(`‚ö†Ô∏è Caution ${depositId} introuvable`);
      return false;
    }

    const deposit = depositResult.rows[0];

    // R√©cup√©rer la conversation
    const conversationId = await getConversationFromReservation(pool, deposit.reservation_uid);
    
    if (!conversationId) {
      console.log(`‚ö†Ô∏è Pas de conversation pour r√©servation ${deposit.reservation_uid}`);
      return false;
    }

    // R√©cup√©rer les infos de la propri√©t√©
    const property = await getPropertyInfo(pool, deposit.property_id);
    const propertyName = property?.name || 'votre logement';

    // Construire le message
    const amountEuros = (deposit.amount_cents / 100).toFixed(2);
    const message = `‚ùå √âchec de l'autorisation

L'autorisation de la caution de ${amountEuros}‚Ç¨ a √©chou√©.

üëâ Veuillez r√©essayer en cliquant ici :
${deposit.checkout_url}

‚ö†Ô∏è Sans cette autorisation, vous ne pourrez pas acc√©der √† ${propertyName}.

Si le probl√®me persiste, contactez votre banque ou utilisez une autre carte.

Merci ! üòä`;

    // Envoyer le message
    return await sendDepositMessage(pool, io, conversationId, message);

  } catch (error) {
    console.error(`‚ùå Erreur sendDepositFailedMessage:`, error);
    return false;
  }
}

/**
 * V√©rifier si une caution bloque l'envoi des infos d'arriv√©e
 */
async function hasValidDeposit(pool, reservationUid) {
  try {
    const result = await pool.query(
      `SELECT status 
       FROM deposits 
       WHERE reservation_uid = $1 
       ORDER BY created_at DESC 
       LIMIT 1`,
      [reservationUid]
    );

    if (result.rows.length === 0) {
      // Pas de caution = OK, on peut envoyer les infos
      return true;
    }

    const status = result.rows[0].status;

    // Les infos d'arriv√©e peuvent √™tre envoy√©es si :
    // - La caution est autoris√©e (authorized)
    // - La caution est captur√©e (captured)
    // - La caution est lib√©r√©e (released)
    const validStatuses = ['authorized', 'captured', 'released'];

    if (validStatuses.includes(status)) {
      return true;
    }

    console.log(`‚è≠Ô∏è Caution en attente (status: ${status}), infos d'arriv√©e bloqu√©es`);
    return false;

  } catch (error) {
    console.error('‚ùå Erreur hasValidDeposit:', error);
    // En cas d'erreur, on autorise l'envoi (fail-safe)
    return true;
  }
}

module.exports = {
  sendDepositReminderJ2,
  sendDepositAuthorizedMessage,
  sendDepositReleasedMessage,
  sendDepositFailedMessage,
  hasValidDeposit
};
